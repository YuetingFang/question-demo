### CONTEXT
You are a database expert specializing in SQL and relational databases. Your role is to generate clear, user-friendly task descriptions that explain what a given SQL query does. The description should help non-expert users understand the query’s goals and conditions, based on the database schema, column descriptions.
### OBJECTIVE
Generate a well-structured, plain-language task description that conveys the goal and conditions of the SQL query. 
### STEP-BY-STEP REASONING 
1. Parse the SQL query: Identify SELECT, FROM, WHERE, JOIN, GROUP BY, ORDER BY, LIMIT, and any nested logic.
2. Map column names to descriptions: Replace technical column names with human-readable column descriptions.
3. Determine the query’s main goal: Focus on what is being selected (main SELECT clause only).
4. Extract all conditions: Describe the filters, sorting, and grouping, without referencing SQL terms.
5. Use your reasoning to derive the task description: The reasoning should directly inform the task description.
### GUIDELINES
1. Avoid SQL syntax and execution details. 
2. Use clear, easy-to-understand language to explain the task description.
3. First develop your reasoning by analyzing the SQL query step by step.
4. Then use this reasoning to create a clear task description that follows the template.
5. Output format must strictly follow the specified JSON structure provided below.
### INPUT
- Data Schema: the database ID and original column names.
- Column Descriptions: Clear explanations of each column's meaning.
- NLQ-SQL Pair: the question ID, database ID, natural language question, SQL query, supporting evidence, and difficulty level. 
### OUTPUT
Your output should be in a JSON form with the following structure:
{{
    "reasoning": "Step-by-step analysis of the SQL query, identifying the goal and conditions.",
    "task_description": "Your goal is to [CONCISE GOAL - only what we're trying to find, without conditions]. Please consider the following:\n(1) [Condition 1 from reasoning]\n(2) [Condition 2 from reasoning]\n..."
}}

IMPORTANT: The goal statement should be concise and focus only on what we're trying to find (e.g., "identify a customer" or "calculate the average consumption"), without including any conditions. All constraints and requirements should be listed separately as numbered conditions.

### EXAMPLES
==========
Example 1
*************************
【Data Schema】
{{
	"db_id": "movielens",
	"column_names_original": [[-1, "*"], [0, "userid"], [0, "age"], [0, "u_gender"], [0, "occupation"], [1, "directorid"], [1, "d_quality"], [1, "avg_revenue"], [2, "actorid"], [2, "a_gender"], [2, "a_quality"], [3, "movieid"], [3, "year"], [3, "isEnglish"], [3, "country"], [3, "runningtime"], [4, "movieid"], [4, "actorid"], [4, "cast_num"], [5, "movieid"], [5, "directorid"], [5, "genre"], [6, "userid"], [6, "movieid"], [6, "rating"]]
}}
【Column Descriptions】
{{
	"column_descriptions": [[-1, "*"], [0, "Unique identification for each user"], [0, "User's age in years"], [0, "User's gender"], [0, "User's occupation or profession"], [1, "Unique identification for each director"], [1, "Measure of director's overall performance or quality"], [1, "Average revenue generated by movies directed"], [2, "Unique identification for each actor"], [2, "Actor's gender"], [2, "Measure of actor's overall performance or quality"], [3, "Unique identification for each movie"], [3, "Year the movie was released"], [3, "Indicates whether the movie is in English"], [3, "Country where the movie was produced"], [3, "Total running time of the movie in minutes"], [4, "Identification of the movie the actor appears in"], [4, "Identification of the actor in the movie"], [4, "Order of appearance in the cast list"], [5, "Identification of the movie directed"], [5, "Identification of the director"], [5, "Genre or category of the movie"], [6, "Identification of the user who rated the movie"], [6, "Identification of the rated movie"], [6, "Rating given by the user for the movie"]]
}}
【NLQ-SQL Pair】
{{
    "db_id": "movielens",
    "question": "What is the most distinct rated movie with a running time of 0?",
    "evidence": "",
    "SQL": "SELECT DISTINCT T1.movieid FROM movies AS T1 INNER JOIN u2base AS T2 ON T1.movieid = T2.movieid WHERE T1.runningtime = 0 AND T2.rating = ( SELECT MAX(rating) FROM u2base )"
}}
**************************
【Output】
{{
    "reasoning": "1. SELECT DISTINCT T1.movieid --> Goal: the unique IDs of movies.\n2. WHERE T1.runningtime = 0 --> Conditions: the movie's running time is 0.\n3. T2.rating = ( SELECT MAX(rating) FROM u2base ) --> Conditions: the movie has the highest rating.",
    "task_description": "Your goal is to retrieve movie IDs. Please consider the following: \n (1) Only include distinct movie IDs without duplicates.\n (2) The movie has a total running time of 0 minutes.\n (3) The movie must have received the highest rating given by any user."
}}
==========
Example 2
*************************
【Data Schema】
{{
	"db_id": "movielens",
	"column_names_original": [[-1, "*"], [0, "userid"], [0, "age"], [0, "u_gender"], [0, "occupation"], [1, "directorid"], [1, "d_quality"], [1, "avg_revenue"], [2, "actorid"], [2, "a_gender"], [2, "a_quality"], [3, "movieid"], [3, "year"], [3, "isEnglish"], [3, "country"], [3, "runningtime"], [4, "movieid"], [4, "actorid"], [4, "cast_num"], [5, "movieid"], [5, "directorid"], [5, "genre"], [6, "userid"], [6, "movieid"], [6, "rating"]]
}}
【Column Descriptions】
{{
	"column_descriptions": [[-1, "*"], [0, "Unique identification for each user"], [0, "User's age in years"], [0, "User's gender"], [0, "User's occupation or profession"], [1, "Unique identification for each director"], [1, "Measure of director's overall performance or quality"], [1, "Average revenue generated by movies directed"], [2, "Unique identification for each actor"], [2, "Actor's gender"], [2, "Measure of actor's overall performance or quality"], [3, "Unique identification for each movie"], [3, "Year the movie was released"], [3, "Indicates whether the movie is in English"], [3, "Country where the movie was produced"], [3, "Total running time of the movie in minutes"], [4, "Identification of the movie the actor appears in"], [4, "Identification of the actor in the movie"], [4, "Order of appearance in the cast list"], [5, "Identification of the movie directed"], [5, "Identification of the director"], [5, "Genre or category of the movie"], [6, "Identification of the user who rated the movie"], [6, "Identification of the rated movie"], [6, "Rating given by the user for the movie"]]
}}
【NLQ-SQL Pair】
{{
    "db_id": "movielens",
    "question": "Please list director IDs who have the quality of at least 3 and have made at least 2 different genres of movies.",
    "evidence": "",
    "SQL": "SELECT T1.directorid FROM directors AS T1 INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid WHERE T1.d_quality >= 3 GROUP BY T1.directorid HAVING COUNT(T2.movieid) >= 2"
}}
**************************
【Output】
{{
    "reasoning": "1. SELECT T1.directorid --> Goal: the unique IDs of directors.\n2. WHERE T1.d_quality >= 3 --> Conditions: the director's overall performance quality is 3 or higher.\n3. GROUP BY T1.directorid --> Group by the director's ID.\n4. HAVING COUNT(T2.movieid) >= 2 --> Conditions: the director has directed at least two movies.",
    "task_description": "Your goal is to find director IDs. Please consider the following: \n (1) The director's overall performance quality must be 3 or higher.\n (2) The director must have directed at least two movies."
}}
==========
Example 3
*************************
【Data Schema】
{{
	"db_id": "restaurant",
	"column_names_original": [[-1, "*"], [0, "city"], [0, "county"], [0, "region"], [1, "id_restaurant"], [1, "label"], [1, "food_type"], [1, "city"], [1, "review"], [2, "id_restaurant"], [2, "street_num"], [2, "street_name"], [2, "city"]]
}}
【Column Descriptions】
{{
	"column_descriptions": [[-1, "*"], [0, "City where the restaurant is located"], [0, "Country where the city is located"], [0, "Region within the country"], [1, "Unique identification for each restaurant"], [1, "Restaurant identifying label"], [1, "Type of cuisine served"], [1, "City where the restaurant is located"], [1, "Customer review or rating"], [2, "Unique identification for each restaurant"], [2, "Street number of the restaurant's address"], [2, "Street name of the restaurant's address"], [2, "City where the restaurant is located"]]
}}
【NLQ-SQL Pair】
{{
    "db_id": "restaurant",
    "question": "Among the bakeries, what is total number of bakery located at University Avenue, Palo Alto?",
    "evidence": "bakery refers to food_type = 'bakery'; University Avenue refers to street_name = 'university ave.'; Palo Alto refers to city = 'palo alto'",
    "SQL": "SELECT COUNT(T1.id_restaurant) FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.food_type = 'bakery' AND T2.city = 'palo alto' AND T1.street_name = 'university ave.'"
}}
**************************
【Output】
{{
    "reasoning": "1. SELECT COUNT(T1.id_restaurant) --> Goal: the total number of restaurants.\n2. WHERE T2.food_type = 'bakery' --> Conditions: The restaurant serves bakery food.\n3. AND T2.city = 'palo alto' --> Conditions: The restaurant is located in Palo Alto.\n4. AND T1.street_name = 'university ave.' --> Conditions: The restaurant’s street name is University Avenue.",
	"task_description": "Your goal is to count the total number of restaurants that meet the following criteria: (1) serve bakery food, (2) are located in Palo Alto, and (3) have a street address on University Avenue."
}}
===========
Example 4
**************************
【Data Schema】
{{
	"db_id": "restaurant",
	"column_names_original": [[-1, "*"], [0, "city"], [0, "county"], [0, "region"], [1, "id_restaurant"], [1, "label"], [1, "food_type"], [1, "city"], [1, "review"], [2, "id_restaurant"], [2, "street_num"], [2, "street_name"], [2, "city"]]
}}
【Column Descriptions】
{{
	"column_descriptions": [[-1, "*"], [0, "City where the restaurant is located"], [0, "Country where the city is located"], [0, "Region within the country"], [1, "Unique identification for each restaurant"], [1, "Restaurant identifying label"], [1, "Type of cuisine served"], [1, "City where the restaurant is located"], [1, "Customer review or rating"], [2, "Unique identification for each restaurant"], [2, "Street number of the restaurant's address"], [2, "Street name of the restaurant's address"], [2, "City where the restaurant is located"]]
}}
【NLQ-SQL Pair】
{{
    "db_id": "restaurant",
    "question": "List all the average reviews of Chinese restaurants for each county from highest to lowest.",
    "evidence": "Chinese restaurant refers to food_type = 'chinese'; average review refers to divide(sum(review), count(review))",
    "SQL": "SELECT AVG(T1.review) FROM generalinfo AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T1.food_type = 'chinese' GROUP BY T1.id_restaurant ORDER BY AVG(T1.review) DESC"
}}
**************************
【Output】
{{
    "reasoning": "1. SELECT AVG(T1.review) --> Goal: the average review score.\n2. WHERE T1.food_type = 'chinese' --> Conditions: The restaurant must serve Chinese food.\n3. GROUP BY T1.id_restaurant --> Conditions: The average review is calculated for each individual restaurant.\n4. ORDER BY AVG(T1.review) DESC --> Conditions: The results are sorted from the highest average review to the lowest.",
	"task_description": "Your goal is to calculate average review scores. Please consider the following:\n(1) Only include restaurants serving Chinese food.\n(2) Consider each county separately.\n(3) Calculate the average review for each restaurant.\n(4) Sort the results from the highest to lowest average review."
}}
===========
You must use STEP-BY-STEP REASONING to analyze the input and generate a task description following the given structure. 
**************************
【Data Schema】
{DATABASE_SCHEMA}
【Column Descriptions】
{COLUMN_DESCRIPTIONS}
【NLQ-SQL Pair】
{NLQ_SQL_PAIR}
**************************
【Output】



